# HTTP 1.1 / HTTP 2

## HTTP/1.1 相对于 HTTP/1.0 性能上的改进

✨1. 持久连接
在 HTTP/1.1 标头中增加了 connection: keep-alive 支持持久连接

在之前的 HTTP1.0 一个 TCP连接 只能对应一个 HTTP 请求,引入持久连接后

在较短的时间内发送多个 HTTP 请求不需要建立多个 TCP 连接


🎈2. 管道传输

支持管道传输 就是一个请求发出去之后,不需要等待 上一个请求的响应结果回来就可以直接发送下一个请求.
但是这也造成 队头阻塞 这一问题,

队头阻塞 服务器是按照请求来响应数据的如果服务器的一个请求响应时间过长,另一个请求就会一直等待,造成队头阻塞.

## HTTP/1.1 的不足之处

随着互联网的发展, 数据的传输量越来越大

- 从 几 kb 大小的消息,到 几MB大小的消息
- 一个页面的资源从 10个 变到 100 个
- 从文本为主的内容变到 一富媒体为主的内容.
- 对页面的实时性要求也越来越高

### HTTP/1.1 的高延迟问题

高延迟使页面的加载速度变慢

1. HTTP/1.1 的并发连接有限 chrome 6
2. 同一个连接只能处理一个 HTTP (请求/响应) 事务
3. 无状态带来的巨大的头部 cookie
    重复传输相同的头部内容,导致效率的下降

4. HTTP/1.1 不支持服务器推送消息


## 解决HTTP/1.1 的性能问题的 HTTP 2
几个特性使 HTTP2 的应用普及率很高
- 在应用层上修改,基于 TCP 协议
- 使用 http/1.1的客户端和服务器可以通过代理转接到 HTTP2
- 在不识别 http/2 的代理服务器可以将请求降到 HTTP/1.1
- 不用开发者做任何的修改,并且不用 改变 HTTP/1.1的任何语义就可以使用 HTTP2

### HTTP 2 的主要特性
1. 标头压缩

​	由于 http/1.1 是无状态的协议,每次请求都需要带上 cookie 来保持状态,还有每次都发重复的 头部内容
​	因此 HTTP2压缩头部内容,如果同时发起多个请求,他们的头部内容是相似的 协议会去除相同的头部信息.

2. 使用二进制格式
    将 HTTP/1.1 的头部和主体信息 以二进制的形式保存, 称为帧

  ![image-20230303222742307](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230303222742307.png)

3. 数据流
HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个流都有 StreamId
4. 多路复用

HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。
移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题， 降低了延迟，⼤幅度提⾼
了连接的利⽤率。

![image-20230303223119726](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230303223119726.png)

5. 服务器推送
HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发
送消息。
举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、 CSS ⽂件等静态资源主动发给客户端， 减
少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。

### HTTP2 中的几个核心概念
1. connection (连接)
   1. 一个 TCP 连接,包含了一个或者多个 Stream

2. stream (流)
   1. 包含了一个或者多个 Message

3. frame (帧)
   1. 最小单位 以二进制的格式存放HTTP/1 中内容

4. message (消息)
   1. 包含 HTTP中的请求或者响应,一个message 可以有多个 frame
   2. 一个消息里有两种帧 1. HEADER 帧 与 DATA 帧,这两者组成了 message


![image-20230303171605198](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230303171605198.png)

### 传输无序,接收组装

跨stream 可以无序,在 同一stream  frame 必须是有序的

使用 streamID 来标记不同的 stream



**streamID 的作用**

实现多路复用的关键

- 接收端的实现可据此并发组装信息

- 同一stream 种的 frame 必须是有序的



推送依赖性请求的关键

- 由客户端建立的流必须是奇数
- 由服务端建立的流必修是偶数



新建立的流的ID 必须大于上一次的流的 ID

Stream 不能复用,长连接耗尽ID 应创建新的连接
