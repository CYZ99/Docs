# HTTP缓存,重定向



HTTP 缓存分为强制缓存和协商缓存

缓存可以在浏览器上缓存,也可以在服务器(代理)上缓存

![image-20230228155719531](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230228155719531.png)

第一步: 发送请求,根据请求头的 `Cache-Control` `expires` 判断缓存是否过期,没有过期直接使用.如果过期则进行协商缓存.



第二步: 缓存已经过期,进行协商缓存根据请求头的 `Etag` `Last-modified`判断服务器上的资源是否更新,没有更新返回 304,空内容 `content-length: 0`

第三步: 都没有命中缓存向服务器发送请求并返回

## 强制缓存

✨客户端第一次发起的请求,直接向服务器获取数据,返回资源和 `Cache-Control`

🏷️再次请求同一个资源 则会比较`cache-control`设置的`max-age`

​	如果不支持 `HTTP1.1` 则使用`expires`头判读是否过期 ,没有过期直接在本地缓存取出数据

![image-20230228160922244](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230228160922244.png)



**Cache-Control的值**

**响应头**

**服务端加 Cache-Control: max-age=31536000**（单位是秒）

**no-store: 告诉所有下游节点不能对响应进行缓存(不适用任何的缓存，不用强制缓存也不用客户端缓存)**

**no-cache: 告诉客户端不能直接使用缓存的响应（不用强制缓存交给服务端来处理），使用前必须在源服务器验证得到304返回码。**

**max-age: 告诉客户端缓存Age超出max-age秒后则缓存过期**

public：表示无论私有缓存或者共享缓存，皆可将该响应缓存

private: 表示该响应不能被代理服务器作为共享缓存使用。

> no-cache: 不使用强制缓存,使用协商缓存, no-store 不使用任何的缓存



**请求头**

max-age:  告诉服务器，客户端不会使用 Age 超出`max-age秒`的值，就资源不会从代理服务器中取到，会去源服务器中找到

max-stale：告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出`max-stal`时，客户端仍打算使用。若`max-stale`后没有值，则表示无论过期多久客户端都可使用

min-fresh:  告诉服务器，Age至少经过`min-fresh`秒后缓存才可使用

no-cache：告诉服务器，不能直接使用代理已有缓存作为响应返回,除非带着缓存条件到上游服务端得到304验证返回码才可使用现有缓存

no-store:  告诉各代理服务器不要对该请求的响应缓存

no-transform:  告诉代理服务器不要修改消息包体的内容

only-if-cached:  告诉服务器仅能返回缓存的响应，否则若没有缓存则返回504错误码



## 协商缓存

🏷️如果`max-age` `expires` 过期(强制缓存失效) 则向服务器发送请求  （头部携带 `If-None-Match` 或`If-Modified-Since` key ）

并且携带一个`ETag` 响应的指纹，(这个`ETag`是用来定义客户端响应的服务器也会有一份，如果服务器的内容修改了，这个标签也会修改，所以当缓存过期时，向服务器发送请求时携带`ETag`,相互对比，便可以判断出内容是否发生修改)  服务器通过对比`ETag` 值一致没有修改返回304，发现修改了返回 200 并且返回新的`ETag`

判断该文件在服务器端是否发生了更新，没有修改则服务器返回304.客户端继续从缓存中取内容。返回304的好处是 content-length = 0 此时客户端便可以使用缓存即可



![image-20230228165142380](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230228165142380.png)

### 资源标识

​	在`Response Headers`中有两种

- `Last-Modified` 资源最后修改的时间
- `Etag` 资源的唯一标识符 （一个字符串）
- 这两个共存的话会优先使用 `Etag`, `Last-Modified`只能精确到秒级
- 如果资源被重复生成，而内容不变，则生成新的 `Etag` 返 回



这里引用 `ChoDocs` 该文档的文章 `(https://chodocs.cn/interview/browser/cache.html#强缓存和协商缓存的区别)`



### Last-Modified 和 If-Modified-Since

- Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。
- If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。

流程：服务器收到请求，发现请求头含有 If-Modified-Since 字段则会对比 If-Modified-Since 字段值与 Last-Modified （最后修改时间），若服务器资源 Last-Modified （最后修改时间）大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200，否则返回 304 代表资源无更新，使用缓存文件。

### ETag 和 If-None-Match

- Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。
- If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。

流程: 服务器收到请求，发现请求头含有 If-None-Match ，则会根据 If-None-Match 的值与该资源所在服务器的 Etag 值做对比，一致则返回状态码 304（代表资源无更新，使用缓存文件），不一致则重新返回新资源，状态码为 200。


### ETag 和 Last-Modified 的区别

- 精确度上：Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度。
- 性能上：Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。
- 优先级：服务器校验优先考虑 Etag。

## 强缓存和协商缓存的区别

- 强缓存不会发送请求到服务器，资源更新了可能浏览器还不知道
- 协商缓存会发请求给服务器，通过字段，服务器能知道资源是否更新
- 大部分 web 浏览器默认开启协商缓存

## 几种刷新的区别

- 点击按钮刷新，按F5刷新 浏览器将本地文件过期，带上`If-None-Match` 和`If-Modified-Sine`发送请求，这就意味着会进行协商缓存。

- 按ctrl+F5刷新 强制刷新不会有任何的缓存。

- 地址栏回车输入地址 按照正常的流程来。

## 重定向

### 为什么需要重定向

1. 当用户使用 `post` 方法提交了一个请求成功后,要跳转到首页需要重定向.
2. 当网页的域名发生变化,访问原有域名需要重定向.
3. 站点正在维护中,需要给用户展示不一样的内容,需要重定向

### 重定向发起的流程

当用户从客户端发起一个请求,服务器发现资源发生移动,返回一个新的 `URI` 以响应报文 `Location`字段的形式

并返回一个 301 的`status code`. 浏览器拿到这个`URI` 使用这个`URI` 再次发起请求.

![image-20230228201606268](https://cyzblog-1305365553.cos.ap-guangzhou.myqcloud.com/image-20230228201606268.png)

### 重定向的响应码

🏷️两个概念

- 原请求： 接收到服务器重定向响应码的请求称为原请求
- 重定向请求： 浏览器接收到重定向响应码之后 发起的重定向请求

**永久重定向，表示资源永久性变更到新的URI**（可以被缓存）

- 301（HTTP/1.0） 重定向请求通常（由于历史原因会把POST请求）使用GET方法，而不管请求用什么方法。
- 308 （HTTP/1.1）重定向的请求必须使用与原请求相同的方法和包体发起请求。

**临时重定向,表示资源只是临时变更URI**  （不会被缓存）

- 302 （HTTP/1.0） 重定向请求通常会使用GET方法，而不管请求用什么方法。

- 303 (HTTP/1.1)  并不表示资源变迁，而是用新的URI的响应表示为原请求表述服务，重定向要求使用GET方法。

  - 由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

  303 状态码和 302 Found 状态码有着相似的功能，`但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。`

  303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，

  比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。

- 307 (HTTP/1.1)   重定向请求必须使用与原请求相同的方法和包体发起请求。

**特殊重定向**

- 300：响应内容协商，告诉浏览器有多种资源表述，要求客户端选择一个合适的
- 304：服务器端验证过期缓存有效后，要求使用客户端缓存, (协商缓存)

🤞注意

----

> - 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。
> - 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。

